# Домашнее задание к занятию «Выстраивание процесса непрерывной интеграции (CI): Github Actions. Покрытие кода с JaCoCo, статический анализ кода: CheckStyle, SpotBugs»

## Задача №1 - Синдром 100%

### Легенда

Вы попали в команду максималистов, которые хотят, чтобы те авто-тесты, которые вы пишете, покрывали код на 100%.

Но вот незадача:
1. Непонятно, что такое 100%
2. Непонятно, как это сделать

Вспоминаем: покрытием кода у нас занимается JaCoCo, но он просто "сигнализирует" о том, что конкретно пошло не так.

Большинство подобных плагинов помимо целей отчётности (`report`) содержат ещё цель `check`, которая обрушает сборку, если не выполнены определённые проверки.

Что вам нужно:
1. Изучить [документацию на плагин](https://www.eclemma.org/jacoco/trunk/doc/maven.html) (а конкретно на цель `check`)
1. Внедрить эту цель в фазу `verify` (обратите внимание, что эта цель итак публикуется в эту фазу)
1. Настроить правила по покрытию на 100% (при этом нужно изучить разницу между счётчиками `INSTRUCTION`, `LINE`, `BRANCH`, `COMPLEXITY`)
1. Выбрать один из счётчиков и добиться 100% покрытия тестами

**Важно**: использовать можно только один из следующих: 
1. `INSTRUCTION`
1. `LINE`
1. `BRANCH`

По шагам:
1. Скачиваете [проект с лекции](https://github.com/netology-code/javaqa-code/tree/master/2.5_ci)
1. Мы просили плагин выполнить цель report для генерации отчёта, вам надо по аналогии с ним добавить ещё один execution, только не забыв заменить в нём report на check. Если не получается, см. как в подсказке ниже. 
1. Изучаете документацию, экспериментируете со счётчиками (`INSTRUCTION`, `LINE`, `BRANCH`)
1. Выбираете один из счётчиков (на ваше усмотрение из первых трёх: `INSTRUCTION`, `LINE`, `BRANCH`)
1. Запускаете, удостоверяетесь, что сборка падает, делаете push в GitHub (так, чтобы в логах осталось, что сборка падала в CI)
1. Анализируете отчёт JaCoCo, смотрите что осталось непокрытым 
1. Дописываете тесты, чтобы обеспечить 100% по выбранному счётчику, делаете push в GitHub (так, чтобы в логах осталось, что сборка зелёная в CI)

Итого: у вас должен быть репозиторий на GitHub, в котором расположен ваш Java-код.

<details>
  <summary>Подсказка №1</summary>
  
  Не всегда все плагины хорошо документированы. Достаточно часто плагин просто запускает какой-то инструмент. И именно в документации самого инструмента раскрываются значения параметров.
  
  Также и с JaCoCo. Вы можете найти описание счётчиков и их назначения [на странице документации самого инструмента JaCoCo](https://www.jacoco.org/jacoco/trunk/doc/) (не плагина).
  
</details>

<details>
  <summary>Подсказка №2 (пример настройки)</summary>
  
  ```
  <executions>
    ...
    <execution>
      <id>check</id>
      <goals>
        <goal>check</goal>
      </goals>
    </execution>
  </executions>
  <configuration>
    <rules>
      <rule>
        <limits>
          <limit>
            <counter>ВАШ COUNTER</counter>
            <value>COVEREDRATIO</value>
            <minimum>100%</minimum>
          </limit>
        </limits>
      </rule>
    </rules>
  </configuration>
  ```
  
</details>

**Важно**: если вы используете Lombok, то покрытие сгенерированных им методов (например, getter/setter'ы тоже учитываются). Это не всегда бывает нужно.

Варианта тут два:
1. Вы читаете документацию на [`excludes`](https://www.jacoco.org/jacoco/trunk/doc/check-mojo.html#excludes), которая позволяет вам исключать целые классы из рассмотрения (не наш вариант)
1. Игнорируете сгенерированные Lombok'ом методы (для этого создайте файл `lombok.config` в корне проекта со следующим содержимым: `lombok.addLombokGeneratedAnnotation = true` и не забудьте сделать `mvn clean`)
